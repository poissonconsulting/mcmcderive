#' derive
#'
#' Calculate derived parameters.
#'
#' @param object The mcmc object.
#' @param ... Unused.
#' @return An mcmc object of the derived parameters.
#' @export
mcmc_derive <- function(object, ...) {
  UseMethod("mcmc_derive")
}

#' @export
mcmc_derive.default <- function(object, expr, values = list(), monitor = ".*", parallel = FALSE, ...) {
  mcmc_derive(as.mcmcr(object), expr = expr, values = values, monitor = monitor, parallel = parallel) 
}

#' derive
#'
#' Calculate derived parameters.
#'
#' @param object The mcmcr object.
#' @param expr A string of the R expression to evaluate.
#' @param values A lists of the values to use.
#' @param monitor A regular expression specifying the new variables to monitor.
#' @param parallel A flag indicating whether to derive samples in parallel using foreach backend.
#' @param ... Unused.
#' @return An mcmcr object of the monitored parameters.
#' @export
#' @examples
#' mcmc_derive(mcmcr::mcmcr_example, "prediction <- (alpha + beta) / sigma")
mcmc_derive.mcmcr <- function(object, expr, values = list(), monitor = ".*", parallel = FALSE, ...) {
  check_string(expr)
  check_list(values)
  check_string(monitor)
  check_flag(parallel)

  values <- lapply(values, as.numeric)

  parameters <- parameters(object)
  names_values <- names(values)
  variables_expr <- all.vars(parse(text = expr))

  if (length(values)) {
    if (is.null(names_values)) error("values must be named")
    if (anyDuplicated(names_values)) error("values names must be unique")

    parameters <- parameters[!parameters %in% names_values]

    values <- values[intersect(names_values, variables_expr)]
  }

  parameters <- intersect(parameters, variables_expr)

  if (!length(parameters)) error("expr must include at least one object parameter")

  object <- subset(object, parameters = parameters)

  variables_expr <- setdiff(variables_expr, parameters)
  variables_expr <- setdiff(variables_expr, names(values))

  if (!length(variables_expr)) error("expr must include at least one new variable")

  values[variables_expr] <- NA

  if (!length(variables_expr[grepl(monitor, variables_expr)]))
    error("monitor '", monitor, "' must match at least one new variable in expr\n", expr)

  monitor <- variables_expr[grepl(monitor, variables_expr)]

  monitor <- sort(monitor)

  object <- plyr::llply(1:nchains(object), derive_chain, object = object,
                     .parallel = parallel, expr = parse(text = expr),
                  values = values, monitor = monitor)

  object <- Reduce(bind_chains, object)

  if (anyNA(object))
    error("monitor '", monitor, "' must not include missing values in expr\n", expr)
  object
}